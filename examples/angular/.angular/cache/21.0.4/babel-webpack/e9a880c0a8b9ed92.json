{"ast":null,"code":"import { PenToolState, HandleMirrorMode } from '../core/types';\nimport { PathManager, PointUtils } from '../core/path';\nimport { HandleManager } from '../core/handles';\n/**\n * Main pen tool controller for interactive drawing\n */\nexport class PenTool {\n  constructor(pathManager, options = {}, callbacks = {}) {\n    this.currentPath = null;\n    this.state = PenToolState.Idle;\n    // Interaction state\n    this.isDragging = false;\n    this.dragStartPoint = null;\n    this.currentAnchorPoint = null;\n    this.isShiftPressed = false;\n    this.isAltPressed = false;\n    this.pathManager = pathManager;\n    this.options = {\n      snapAngle: options.snapAngle ?? 45,\n      closePathThreshold: options.closePathThreshold ?? 10,\n      defaultHandleLength: options.defaultHandleLength ?? 50\n    };\n    this.callbacks = callbacks;\n  }\n  /**\n   * Get current tool state\n   */\n  getState() {\n    return this.state;\n  }\n  /**\n   * Get current active path\n   */\n  getCurrentPath() {\n    return this.currentPath;\n  }\n  /**\n   * Handle mouse down event\n   */\n  onMouseDown(position) {\n    if (this.state === PenToolState.EditMode) {\n      return; // Handled by edit mode\n    }\n    this.isDragging = true;\n    this.dragStartPoint = position;\n    // Check if clicking near the start point to close path\n    if (this.currentPath && this.currentPath.anchorPoints.length > 0) {\n      const firstPoint = this.currentPath.anchorPoints[0];\n      const distance = PointUtils.distance(position, firstPoint.position);\n      if (distance <= this.options.closePathThreshold) {\n        // Close the path\n        this.pathManager.closePath(this.currentPath);\n        this.notifyPathModified();\n        this.finishPath();\n        return;\n      }\n    }\n    // Start a new path if none exists\n    if (!this.currentPath) {\n      this.currentPath = this.pathManager.createPath();\n      this.setState(PenToolState.Drawing);\n    }\n  }\n  /**\n   * Handle mouse move event\n   */\n  onMouseMove(position) {\n    // Check for close path hover\n    if (this.currentPath && this.currentPath.anchorPoints.length > 0) {\n      const firstPoint = this.currentPath.anchorPoints[0];\n      const distance = PointUtils.distance(position, firstPoint.position);\n      const canClose = distance <= this.options.closePathThreshold;\n      if (this.callbacks.onClosePathHover) {\n        this.callbacks.onClosePathHover(canClose);\n      }\n    }\n    if (this.isDragging && this.dragStartPoint && this.currentPath) {\n      this.setState(PenToolState.DraggingHandle);\n      // Calculate handle position\n      let handlePosition = PointUtils.subtract(position, this.dragStartPoint);\n      // Apply angle snapping if shift is pressed\n      if (this.isShiftPressed) {\n        handlePosition = this.snapToAngle(handlePosition);\n      }\n      // Update or create the current anchor point with handles\n      if (!this.currentAnchorPoint) {\n        this.currentAnchorPoint = this.pathManager.addAnchorPoint(this.currentPath, this.dragStartPoint, null, handlePosition);\n        // Set to independent mode if Alt is pressed\n        if (this.isAltPressed) {\n          this.currentAnchorPoint.mirrorMode = HandleMirrorMode.Independent;\n        }\n      } else {\n        // Temporarily set to independent mode if Alt is pressed\n        const originalMode = this.currentAnchorPoint.mirrorMode;\n        if (this.isAltPressed) {\n          this.currentAnchorPoint.mirrorMode = HandleMirrorMode.Independent;\n        }\n        HandleManager.updateHandle(this.currentAnchorPoint, true, position);\n        if (this.isAltPressed) {\n          this.currentAnchorPoint.mirrorMode = originalMode;\n        }\n      }\n      this.notifyPathModified();\n    }\n  }\n  /**\n   * Handle mouse up event\n   */\n  onMouseUp(position) {\n    if (!this.isDragging || !this.dragStartPoint || !this.currentPath) {\n      return;\n    }\n    const dragDistance = PointUtils.distance(this.dragStartPoint, position);\n    if (dragDistance < 2) {\n      // Click without drag - add straight line point\n      if (!this.currentAnchorPoint) {\n        this.currentAnchorPoint = this.pathManager.addAnchorPoint(this.currentPath, this.dragStartPoint, null, null);\n        this.notifyPathModified();\n      }\n    } else {\n      // Dragged - the anchor point with handles was already created/updated\n      // Just finalize the state\n    }\n    // Reset for next point\n    this.isDragging = false;\n    this.dragStartPoint = null;\n    this.currentAnchorPoint = null;\n    this.setState(PenToolState.Drawing);\n  }\n  /**\n   * Handle keyboard down event\n   */\n  onKeyDown(key) {\n    if (key === 'Shift') {\n      this.isShiftPressed = true;\n    } else if (key === 'Alt') {\n      this.isAltPressed = true;\n    } else if (key === 'Escape') {\n      this.finishPath();\n    } else if (key === 'Enter') {\n      if (this.currentPath) {\n        this.pathManager.closePath(this.currentPath);\n        this.notifyPathModified();\n        this.finishPath();\n      }\n    }\n  }\n  /**\n   * Handle keyboard up event\n   */\n  onKeyUp(key) {\n    if (key === 'Shift') {\n      this.isShiftPressed = false;\n    } else if (key === 'Alt') {\n      this.isAltPressed = false;\n    }\n  }\n  /**\n   * Add a point to an existing path segment\n   */\n  addPointToPath(path, segmentIndex, t) {\n    const segments = this.pathManager.getSegments(path);\n    if (segmentIndex < 0 || segmentIndex >= segments.length) {\n      throw new Error('Invalid segment index');\n    }\n    const segment = segments[segmentIndex];\n    let newPosition;\n    if (segment.type === 'line') {\n      // Linear interpolation for straight lines\n      const t1 = 1 - t;\n      newPosition = {\n        x: t1 * segment.startPoint.position.x + t * segment.endPoint.position.x,\n        y: t1 * segment.startPoint.position.y + t * segment.endPoint.position.y\n      };\n    } else {\n      // Cubic Bezier interpolation for curves\n      newPosition = PathManager.cubicBezierPoint(segment.startPoint.position, segment.controlPoint1, segment.controlPoint2, segment.endPoint.position, t);\n    }\n    // Insert the new point\n    const newPoint = this.pathManager.insertAnchorPoint(path, segmentIndex + 1, newPosition);\n    // Create default handles based on adjacent points\n    const prevPoint = path.anchorPoints[segmentIndex];\n    const nextPoint = path.anchorPoints[(segmentIndex + 2) % path.anchorPoints.length];\n    HandleManager.createDefaultHandles(newPoint, prevPoint.position, nextPoint.position, this.options.defaultHandleLength);\n    this.notifyPathModified();\n    return newPoint;\n  }\n  /**\n   * Finish the current path and reset state\n   */\n  finishPath() {\n    this.currentPath = null;\n    this.currentAnchorPoint = null;\n    this.isDragging = false;\n    this.dragStartPoint = null;\n    this.setState(PenToolState.Idle);\n  }\n  /**\n   * Snap a vector to the nearest angle increment\n   */\n  snapToAngle(vector) {\n    const angle = Math.atan2(vector.y, vector.x);\n    const length = Math.sqrt(vector.x * vector.x + vector.y * vector.y);\n    const snapRadians = this.options.snapAngle * Math.PI / 180;\n    const snappedAngle = Math.round(angle / snapRadians) * snapRadians;\n    return {\n      x: Math.cos(snappedAngle) * length,\n      y: Math.sin(snappedAngle) * length\n    };\n  }\n  /**\n   * Set tool state and notify callback\n   */\n  setState(newState) {\n    if (this.state !== newState) {\n      this.state = newState;\n      if (this.callbacks.onStateChange) {\n        this.callbacks.onStateChange(newState);\n      }\n    }\n  }\n  /**\n   * Notify that path was modified\n   */\n  notifyPathModified() {\n    if (this.currentPath && this.callbacks.onPathModified) {\n      this.callbacks.onPathModified(this.currentPath);\n    }\n  }\n  /**\n   * Reset the tool\n   */\n  reset() {\n    this.finishPath();\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}