{"ast":null,"code":"import { HandleManager } from '../core/handles';\n/**\n * SVG renderer for paths, anchor points, handles, and UI feedback\n */\nexport class PathRenderer {\n  constructor(svg, options = {}) {\n    this.svg = svg;\n    this.options = {\n      strokeColor: options.strokeColor ?? '#000000',\n      strokeWidth: options.strokeWidth ?? 2,\n      fillColor: options.fillColor ?? 'none',\n      selectionColor: options.selectionColor ?? '#0066FF',\n      anchorPointColor: options.anchorPointColor ?? '#FFFFFF',\n      anchorPointSize: options.anchorPointSize ?? 6,\n      handleColor: options.handleColor ?? '#0066FF',\n      previewColor: options.previewColor ?? '#999999',\n      showAllHandles: options.showAllHandles ?? false\n    };\n    // Create layer groups\n    this.pathsGroup = this.createGroup('paths');\n    this.handlesGroup = this.createGroup('handles');\n    this.anchorPointsGroup = this.createGroup('anchor-points');\n    this.previewGroup = this.createGroup('preview');\n  }\n  /**\n   * Render all paths\n   */\n  renderPaths(pathManager) {\n    // Clear existing paths\n    this.pathsGroup.innerHTML = '';\n    const paths = pathManager.getAllPaths();\n    for (const path of paths) {\n      this.renderPath(path, pathManager);\n    }\n  }\n  /**\n   * Render a single path\n   */\n  renderPath(path, pathManager) {\n    const pathData = pathManager.toSVGPath(path);\n    if (!pathData) return;\n    const pathElement = document.createElementNS('http://www.w3.org/2000/svg', 'path');\n    pathElement.setAttribute('d', pathData);\n    pathElement.setAttribute('stroke', path.stroke || this.options.strokeColor);\n    pathElement.setAttribute('stroke-width', path.strokeWidth.toString());\n    pathElement.setAttribute('fill', path.fill || this.options.fillColor);\n    pathElement.setAttribute('data-path-id', path.id);\n    if (path.selected) {\n      pathElement.setAttribute('stroke', this.options.selectionColor);\n    }\n    this.pathsGroup.appendChild(pathElement);\n  }\n  /**\n   * Render anchor points for all paths\n   */\n  renderAnchorPoints(pathManager) {\n    this.anchorPointsGroup.innerHTML = '';\n    const paths = pathManager.getAllPaths();\n    for (const path of paths) {\n      for (const point of path.anchorPoints) {\n        this.renderAnchorPoint(point);\n      }\n    }\n  }\n  /**\n   * Render a single anchor point\n   */\n  renderAnchorPoint(point) {\n    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');\n    circle.setAttribute('cx', point.position.x.toString());\n    circle.setAttribute('cy', point.position.y.toString());\n    circle.setAttribute('r', this.options.anchorPointSize.toString());\n    circle.setAttribute('fill', this.options.anchorPointColor);\n    circle.setAttribute('stroke', point.selected ? this.options.selectionColor : '#000000');\n    circle.setAttribute('stroke-width', '1.5');\n    circle.setAttribute('data-point-id', point.id);\n    this.anchorPointsGroup.appendChild(circle);\n  }\n  /**\n   * Render handles for anchor points\n   */\n  renderHandles(pathManager) {\n    this.handlesGroup.innerHTML = '';\n    const paths = pathManager.getAllPaths();\n    for (const path of paths) {\n      for (const point of path.anchorPoints) {\n        const showHandles = this.options.showAllHandles || point.selected;\n        if (showHandles) {\n          this.renderPointHandles(point);\n        }\n      }\n    }\n  }\n  /**\n   * Render handles for a specific anchor point\n   */\n  renderPointHandles(point) {\n    // Render handle in\n    if (point.handleIn?.visible) {\n      const handlePos = HandleManager.getAbsoluteHandlePosition(point, false);\n      if (handlePos) {\n        this.renderHandle(point.position, handlePos, 'in', point.id);\n      }\n    }\n    // Render handle out\n    if (point.handleOut?.visible) {\n      const handlePos = HandleManager.getAbsoluteHandlePosition(point, true);\n      if (handlePos) {\n        this.renderHandle(point.position, handlePos, 'out', point.id);\n      }\n    }\n  }\n  /**\n   * Render a single handle\n   */\n  renderHandle(anchorPos, handlePos, type, pointId) {\n    // Handle line\n    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');\n    line.setAttribute('x1', anchorPos.x.toString());\n    line.setAttribute('y1', anchorPos.y.toString());\n    line.setAttribute('x2', handlePos.x.toString());\n    line.setAttribute('y2', handlePos.y.toString());\n    line.setAttribute('stroke', this.options.handleColor);\n    line.setAttribute('stroke-width', '1');\n    line.setAttribute('data-handle-type', type);\n    line.setAttribute('data-point-id', pointId);\n    this.handlesGroup.appendChild(line);\n    // Handle endpoint\n    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');\n    circle.setAttribute('cx', handlePos.x.toString());\n    circle.setAttribute('cy', handlePos.y.toString());\n    circle.setAttribute('r', '4');\n    circle.setAttribute('fill', this.options.handleColor);\n    circle.setAttribute('stroke', '#FFFFFF');\n    circle.setAttribute('stroke-width', '1.5');\n    circle.setAttribute('data-handle-type', type);\n    circle.setAttribute('data-point-id', pointId);\n    this.handlesGroup.appendChild(circle);\n  }\n  /**\n   * Render preview line from last point to cursor\n   */\n  renderPreviewLine(fromPoint, toPoint) {\n    this.previewGroup.innerHTML = '';\n    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');\n    line.setAttribute('x1', fromPoint.x.toString());\n    line.setAttribute('y1', fromPoint.y.toString());\n    line.setAttribute('x2', toPoint.x.toString());\n    line.setAttribute('y2', toPoint.y.toString());\n    line.setAttribute('stroke', this.options.previewColor);\n    line.setAttribute('stroke-width', '1');\n    line.setAttribute('stroke-dasharray', '4 4');\n    this.previewGroup.appendChild(line);\n  }\n  /**\n   * Render preview curve while dragging handle\n   */\n  renderPreviewCurve(startPoint, controlPoint1, controlPoint2, endPoint) {\n    this.previewGroup.innerHTML = '';\n    const pathData = `M ${startPoint.x} ${startPoint.y} C ${controlPoint1.x} ${controlPoint1.y}, ${controlPoint2.x} ${controlPoint2.y}, ${endPoint.x} ${endPoint.y}`;\n    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');\n    path.setAttribute('d', pathData);\n    path.setAttribute('stroke', this.options.previewColor);\n    path.setAttribute('stroke-width', '1');\n    path.setAttribute('fill', 'none');\n    path.setAttribute('stroke-dasharray', '4 4');\n    this.previewGroup.appendChild(path);\n  }\n  /**\n   * Clear preview elements\n   */\n  clearPreview() {\n    this.previewGroup.innerHTML = '';\n  }\n  /**\n   * Render close-path indicator\n   */\n  renderClosePathIndicator(point, show) {\n    const indicatorId = 'close-path-indicator';\n    const existing = this.svg.getElementById(indicatorId);\n    if (!show) {\n      if (existing) {\n        existing.remove();\n      }\n      return;\n    }\n    if (!existing) {\n      const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');\n      circle.setAttribute('id', indicatorId);\n      circle.setAttribute('r', '8');\n      circle.setAttribute('fill', 'none');\n      circle.setAttribute('stroke', this.options.selectionColor);\n      circle.setAttribute('stroke-width', '2');\n      this.previewGroup.appendChild(circle);\n    }\n    const indicator = this.svg.getElementById(indicatorId);\n    if (indicator) {\n      indicator.setAttribute('cx', point.x.toString());\n      indicator.setAttribute('cy', point.y.toString());\n    }\n  }\n  /**\n   * Render hover preview point for adding to paths\n   */\n  renderHoverPreviewPoint(point) {\n    const previewId = 'hover-preview-point';\n    const existing = this.svg.getElementById(previewId);\n    if (!point) {\n      if (existing) {\n        existing.remove();\n      }\n      return;\n    }\n    if (!existing) {\n      const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');\n      circle.setAttribute('id', previewId);\n      circle.setAttribute('r', '4');\n      circle.setAttribute('fill', this.options.selectionColor);\n      circle.setAttribute('fill-opacity', '0.5');\n      circle.setAttribute('stroke', this.options.selectionColor);\n      circle.setAttribute('stroke-width', '1.5');\n      circle.setAttribute('pointer-events', 'none');\n      this.previewGroup.appendChild(circle);\n    }\n    const preview = this.svg.getElementById(previewId);\n    if (preview) {\n      preview.setAttribute('cx', point.x.toString());\n      preview.setAttribute('cy', point.y.toString());\n    }\n  }\n  /**\n   * Update the entire view\n   */\n  update(pathManager) {\n    this.renderPaths(pathManager);\n    this.renderHandles(pathManager);\n    this.renderAnchorPoints(pathManager);\n  }\n  /**\n   * Clear all rendered elements\n   */\n  clear() {\n    this.pathsGroup.innerHTML = '';\n    this.anchorPointsGroup.innerHTML = '';\n    this.handlesGroup.innerHTML = '';\n    this.previewGroup.innerHTML = '';\n  }\n  /**\n   * Create an SVG group element\n   */\n  createGroup(className) {\n    const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');\n    group.setAttribute('class', className);\n    this.svg.appendChild(group);\n    return group;\n  }\n  /**\n   * Set render options\n   */\n  setOptions(options) {\n    Object.assign(this.options, options);\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}