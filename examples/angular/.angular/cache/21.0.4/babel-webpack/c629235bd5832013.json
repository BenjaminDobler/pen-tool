{"ast":null,"code":"import { HandleMirrorMode } from './types';\nimport { PointUtils } from './path';\n/**\n * Handle manipulation and management\n */\nexport class HandleManager {\n  /**\n   * Update a handle position while respecting mirror mode\n   */\n  static updateHandle(anchorPoint, isOutHandle, newHandlePosition) {\n    const relativePosition = PointUtils.subtract(newHandlePosition, anchorPoint.position);\n    if (isOutHandle) {\n      // Update the out handle\n      if (!anchorPoint.handleOut) {\n        anchorPoint.handleOut = {\n          position: relativePosition,\n          visible: true\n        };\n      } else {\n        anchorPoint.handleOut.position = relativePosition;\n        anchorPoint.handleOut.visible = true;\n      }\n      // Mirror to in handle based on mode\n      this.mirrorHandle(anchorPoint, false);\n    } else {\n      // Update the in handle\n      if (!anchorPoint.handleIn) {\n        anchorPoint.handleIn = {\n          position: relativePosition,\n          visible: true\n        };\n      } else {\n        anchorPoint.handleIn.position = relativePosition;\n        anchorPoint.handleIn.visible = true;\n      }\n      // Mirror to out handle based on mode\n      this.mirrorHandle(anchorPoint, true);\n    }\n  }\n  /**\n   * Mirror a handle based on the anchor point's mirror mode\n   */\n  static mirrorHandle(anchorPoint, mirrorToOut) {\n    const sourceHandle = mirrorToOut ? anchorPoint.handleIn : anchorPoint.handleOut;\n    const targetHandle = mirrorToOut ? anchorPoint.handleOut : anchorPoint.handleIn;\n    if (!sourceHandle || !sourceHandle.visible) {\n      return;\n    }\n    switch (anchorPoint.mirrorMode) {\n      case HandleMirrorMode.Mirrored:\n        {\n          // Mirror both angle and length\n          const mirrored = {\n            x: -sourceHandle.position.x,\n            y: -sourceHandle.position.y\n          };\n          if (!targetHandle) {\n            if (mirrorToOut) {\n              anchorPoint.handleOut = {\n                position: mirrored,\n                visible: true\n              };\n            } else {\n              anchorPoint.handleIn = {\n                position: mirrored,\n                visible: true\n              };\n            }\n          } else {\n            targetHandle.position = mirrored;\n            targetHandle.visible = true;\n          }\n          break;\n        }\n      case HandleMirrorMode.AngleLocked:\n        {\n          // Mirror angle only, preserve length of target handle\n          if (!targetHandle || !targetHandle.visible) {\n            // If target doesn't exist, create with same length as source\n            const mirrored = {\n              x: -sourceHandle.position.x,\n              y: -sourceHandle.position.y\n            };\n            if (mirrorToOut) {\n              anchorPoint.handleOut = {\n                position: mirrored,\n                visible: true\n              };\n            } else {\n              anchorPoint.handleIn = {\n                position: mirrored,\n                visible: true\n              };\n            }\n          } else {\n            // Preserve target length, mirror angle\n            const sourceLength = Math.sqrt(sourceHandle.position.x ** 2 + sourceHandle.position.y ** 2);\n            const targetLength = Math.sqrt(targetHandle.position.x ** 2 + targetHandle.position.y ** 2);\n            if (sourceLength > 0) {\n              const scale = targetLength / sourceLength;\n              targetHandle.position = {\n                x: -sourceHandle.position.x * scale,\n                y: -sourceHandle.position.y * scale\n              };\n            }\n          }\n          break;\n        }\n      case HandleMirrorMode.Independent:\n        // Do nothing - handles are independent\n        break;\n    }\n  }\n  /**\n   * Set handle mirror mode and adjust handles accordingly\n   */\n  static setMirrorMode(anchorPoint, mode) {\n    anchorPoint.mirrorMode = mode;\n    // If switching to a mirroring mode, update handles\n    if (mode !== HandleMirrorMode.Independent) {\n      // Use the out handle as reference if it exists\n      if (anchorPoint.handleOut?.visible) {\n        this.mirrorHandle(anchorPoint, false);\n      } else if (anchorPoint.handleIn?.visible) {\n        this.mirrorHandle(anchorPoint, true);\n      }\n    }\n  }\n  /**\n   * Create default handles for a point based on adjacent points\n   */\n  static createDefaultHandles(anchorPoint, prevPoint, nextPoint, handleLength = 50) {\n    if (!prevPoint && !nextPoint) {\n      return;\n    }\n    if (prevPoint && nextPoint) {\n      // Point is between two other points - create smooth curve\n      const angle = PointUtils.angle(prevPoint, nextPoint);\n      const offset = handleLength / 3;\n      anchorPoint.handleIn = {\n        position: {\n          x: -Math.cos(angle) * offset,\n          y: -Math.sin(angle) * offset\n        },\n        visible: true\n      };\n      anchorPoint.handleOut = {\n        position: {\n          x: Math.cos(angle) * offset,\n          y: Math.sin(angle) * offset\n        },\n        visible: true\n      };\n    } else if (prevPoint) {\n      // Only previous point exists\n      const angle = PointUtils.angle(prevPoint, anchorPoint.position);\n      const offset = handleLength / 3;\n      anchorPoint.handleIn = {\n        position: {\n          x: -Math.cos(angle) * offset,\n          y: -Math.sin(angle) * offset\n        },\n        visible: true\n      };\n    } else if (nextPoint) {\n      // Only next point exists\n      const angle = PointUtils.angle(anchorPoint.position, nextPoint);\n      const offset = handleLength / 3;\n      anchorPoint.handleOut = {\n        position: {\n          x: Math.cos(angle) * offset,\n          y: Math.sin(angle) * offset\n        },\n        visible: true\n      };\n    }\n    anchorPoint.mirrorMode = HandleMirrorMode.Mirrored;\n  }\n  /**\n   * Remove handles from a point (convert to straight)\n   */\n  static removeHandles(anchorPoint) {\n    anchorPoint.handleIn = null;\n    anchorPoint.handleOut = null;\n  }\n  /**\n   * Get absolute position of a handle in world coordinates\n   */\n  static getAbsoluteHandlePosition(anchorPoint, isOutHandle) {\n    const handle = isOutHandle ? anchorPoint.handleOut : anchorPoint.handleIn;\n    if (!handle || !handle.visible) {\n      return null;\n    }\n    return PointUtils.add(anchorPoint.position, handle.position);\n  }\n  /**\n   * Check if a position is near a handle\n   */\n  static isNearHandle(anchorPoint, position, threshold = 10) {\n    // Check out handle\n    if (anchorPoint.handleOut?.visible) {\n      const handlePos = this.getAbsoluteHandlePosition(anchorPoint, true);\n      if (handlePos) {\n        const distance = PointUtils.distance(position, handlePos);\n        if (distance <= threshold) {\n          return {\n            isOut: true,\n            distance\n          };\n        }\n      }\n    }\n    // Check in handle\n    if (anchorPoint.handleIn?.visible) {\n      const handlePos = this.getAbsoluteHandlePosition(anchorPoint, false);\n      if (handlePos) {\n        const distance = PointUtils.distance(position, handlePos);\n        if (distance <= threshold) {\n          return {\n            isOut: false,\n            distance\n          };\n        }\n      }\n    }\n    return null;\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}