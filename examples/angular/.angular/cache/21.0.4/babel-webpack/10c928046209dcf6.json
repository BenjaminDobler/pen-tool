{"ast":null,"code":"import { HandleMirrorMode } from '../core/types';\nimport { PathManager, PointUtils } from '../core/path';\nimport { HandleManager } from '../core/handles';\n/**\n * Edit mode for manipulating existing paths\n */\nexport class EditMode {\n  constructor(pathManager, callbacks = {}) {\n    this.selectedPoints = new Set();\n    // Interaction state\n    this.isDragging = false;\n    this.dragType = null;\n    this.dragTarget = null;\n    this.dragStartPos = null;\n    this.initialPointPos = null;\n    this.isShiftPressed = false;\n    this.isAltPressed = false;\n    this.originalMirrorMode = null;\n    this.pathManager = pathManager;\n    this.callbacks = callbacks;\n  }\n  /**\n   * Handle mouse down in edit mode\n   */\n  onMouseDown(position) {\n    // Check all paths for hit detection\n    const allPaths = this.pathManager.getAllPaths();\n    // First, check for handle hits (they have priority)\n    for (const path of allPaths) {\n      for (const point of path.anchorPoints) {\n        const handleHit = HandleManager.isNearHandle(point, position, 8);\n        if (handleHit) {\n          this.startDraggingHandle(path, point, handleHit.isOut);\n          this.dragStartPos = position;\n          return true;\n        }\n      }\n    }\n    // Then check for anchor point hits\n    for (const path of allPaths) {\n      const hit = this.pathManager.findClosestPointOnPath(path, position, 8);\n      if (hit) {\n        this.startDraggingPoint(path, hit.anchorPoint);\n        this.dragStartPos = position;\n        this.initialPointPos = {\n          ...hit.anchorPoint.position\n        };\n        return true;\n      }\n    }\n    // No hit - clear selection unless shift is pressed\n    if (!this.isShiftPressed) {\n      this.clearSelection();\n    }\n    return false;\n  }\n  /**\n   * Handle mouse move in edit mode\n   */\n  onMouseMove(position) {\n    if (!this.isDragging || !this.dragTarget || !this.dragStartPos) {\n      return;\n    }\n    const {\n      path,\n      point\n    } = this.dragTarget;\n    if (this.dragType === 'point' && this.initialPointPos) {\n      // Move the anchor point\n      const delta = PointUtils.subtract(position, this.dragStartPos);\n      const newPosition = PointUtils.add(this.initialPointPos, delta);\n      this.pathManager.moveAnchorPoint(path, point.id, newPosition);\n      this.notifyPathModified(path);\n    } else if (this.dragType === 'handle-in' || this.dragType === 'handle-out') {\n      // Move the handle\n      const isOut = this.dragType === 'handle-out';\n      // Temporarily set to independent mode if Alt is pressed\n      if (this.isAltPressed && this.originalMirrorMode === null) {\n        this.originalMirrorMode = point.mirrorMode;\n        point.mirrorMode = HandleMirrorMode.Independent;\n      } else if (!this.isAltPressed && this.originalMirrorMode !== null) {\n        point.mirrorMode = this.originalMirrorMode;\n        this.originalMirrorMode = null;\n      }\n      HandleManager.updateHandle(point, isOut, position);\n      this.notifyPathModified(path);\n    }\n  }\n  /**\n   * Handle mouse up in edit mode\n   */\n  onMouseUp(_position) {\n    // Restore original mirror mode if Alt was pressed\n    if (this.originalMirrorMode !== null && this.dragTarget) {\n      this.dragTarget.point.mirrorMode = this.originalMirrorMode;\n      this.originalMirrorMode = null;\n    }\n    this.isDragging = false;\n    this.dragType = null;\n    this.dragTarget = null;\n    this.dragStartPos = null;\n    this.initialPointPos = null;\n  }\n  /**\n   * Handle double-click to add point to path\n   */\n  onDoubleClick(position) {\n    const allPaths = this.pathManager.getAllPaths();\n    for (const path of allPaths) {\n      const segments = this.pathManager.getSegments(path);\n      for (let i = 0; i < segments.length; i++) {\n        const segment = segments[i];\n        const closestPoint = this.findClosestPointOnSegment(segment, position);\n        if (closestPoint && closestPoint.distance < 10) {\n          // Add point to this segment\n          const newPoint = this.pathManager.insertAnchorPoint(path, i + 1, closestPoint.position);\n          // Create default handles\n          HandleManager.createDefaultHandles(newPoint, segment.startPoint.position, segment.endPoint.position);\n          this.selectPoint(newPoint);\n          this.notifyPathModified(path);\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  /**\n   * Handle keyboard events\n   */\n  onKeyDown(key) {\n    if (key === 'Shift') {\n      this.isShiftPressed = true;\n    } else if (key === 'Alt') {\n      this.isAltPressed = true;\n    } else if (key === 'Delete' || key === 'Backspace') {\n      this.deleteSelectedPoints();\n    }\n  }\n  /**\n   * Handle keyboard up events\n   */\n  onKeyUp(key) {\n    if (key === 'Shift') {\n      this.isShiftPressed = false;\n    } else if (key === 'Alt') {\n      this.isAltPressed = false;\n      // Restore original mirror mode if we were dragging\n      if (this.originalMirrorMode !== null && this.dragTarget) {\n        this.dragTarget.point.mirrorMode = this.originalMirrorMode;\n        this.originalMirrorMode = null;\n      }\n    }\n  }\n  /**\n   * Delete selected points\n   */\n  deleteSelectedPoints() {\n    const allPaths = this.pathManager.getAllPaths();\n    for (const path of allPaths) {\n      const pointsToDelete = path.anchorPoints.filter(p => this.selectedPoints.has(p.id));\n      for (const point of pointsToDelete) {\n        this.pathManager.removeAnchorPoint(path, point.id);\n        this.selectedPoints.delete(point.id);\n      }\n      if (pointsToDelete.length > 0) {\n        this.notifyPathModified(path);\n      }\n    }\n    this.notifySelectionChange();\n  }\n  /**\n   * Start dragging a point\n   */\n  startDraggingPoint(path, point) {\n    this.isDragging = true;\n    this.dragType = 'point';\n    this.dragTarget = {\n      path,\n      point\n    };\n    if (!this.isShiftPressed) {\n      this.clearSelection();\n    }\n    this.selectPoint(point);\n  }\n  /**\n   * Start dragging a handle\n   */\n  startDraggingHandle(path, point, isOut) {\n    this.isDragging = true;\n    this.dragType = isOut ? 'handle-out' : 'handle-in';\n    this.dragTarget = {\n      path,\n      point\n    };\n  }\n  /**\n   * Select a point\n   */\n  selectPoint(point) {\n    point.selected = true;\n    this.selectedPoints.add(point.id);\n    this.notifySelectionChange();\n  }\n  /**\n   * Clear selection\n   */\n  clearSelection() {\n    const allPaths = this.pathManager.getAllPaths();\n    for (const path of allPaths) {\n      for (const point of path.anchorPoints) {\n        if (point.selected) {\n          point.selected = false;\n        }\n      }\n    }\n    this.selectedPoints.clear();\n    this.notifySelectionChange();\n  }\n  /**\n   * Find closest point on a segment\n   */\n  findClosestPointOnSegment(segment, position) {\n    let minDistance = Infinity;\n    let closestPoint = null;\n    // Sample points along the segment\n    const samples = 20;\n    for (let i = 0; i <= samples; i++) {\n      const t = i / samples;\n      let point;\n      if (segment.type === 'line') {\n        point = {\n          x: (1 - t) * segment.startPoint.position.x + t * segment.endPoint.position.x,\n          y: (1 - t) * segment.startPoint.position.y + t * segment.endPoint.position.y\n        };\n      } else {\n        point = PathManager.cubicBezierPoint(segment.startPoint.position, segment.controlPoint1, segment.controlPoint2, segment.endPoint.position, t);\n      }\n      const distance = PointUtils.distance(position, point);\n      if (distance < minDistance) {\n        minDistance = distance;\n        closestPoint = point;\n      }\n    }\n    return closestPoint ? {\n      position: closestPoint,\n      distance: minDistance\n    } : null;\n  }\n  /**\n   * Notify selection change\n   */\n  notifySelectionChange() {\n    if (this.callbacks.onSelectionChange) {\n      const selectedPointsList = [];\n      const allPaths = this.pathManager.getAllPaths();\n      for (const path of allPaths) {\n        for (const point of path.anchorPoints) {\n          if (this.selectedPoints.has(point.id)) {\n            selectedPointsList.push(point);\n          }\n        }\n      }\n      this.callbacks.onSelectionChange(selectedPointsList);\n    }\n  }\n  /**\n   * Notify path modified\n   */\n  notifyPathModified(path) {\n    if (this.callbacks.onPathModified) {\n      this.callbacks.onPathModified(path);\n    }\n  }\n  /**\n   * Get selected points\n   */\n  getSelectedPoints() {\n    const selected = [];\n    const allPaths = this.pathManager.getAllPaths();\n    for (const path of allPaths) {\n      for (const point of path.anchorPoints) {\n        if (this.selectedPoints.has(point.id)) {\n          selected.push(point);\n        }\n      }\n    }\n    return selected;\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}