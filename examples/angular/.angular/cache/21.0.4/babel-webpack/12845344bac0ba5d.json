{"ast":null,"code":"import { SegmentType, HandleMirrorMode, StrokeCapStyle } from './types';\n/**\n * Utility functions for working with points\n */\nexport class PointUtils {\n  /**\n   * Calculate distance between two points\n   */\n  static distance(p1, p2) {\n    const dx = p2.x - p1.x;\n    const dy = p2.y - p1.y;\n    return Math.sqrt(dx * dx + dy * dy);\n  }\n  /**\n   * Calculate angle between two points in radians\n   */\n  static angle(p1, p2) {\n    return Math.atan2(p2.y - p1.y, p2.x - p1.x);\n  }\n  /**\n   * Add two points\n   */\n  static add(p1, p2) {\n    return {\n      x: p1.x + p2.x,\n      y: p1.y + p2.y\n    };\n  }\n  /**\n   * Subtract two points\n   */\n  static subtract(p1, p2) {\n    return {\n      x: p1.x - p2.x,\n      y: p1.y - p2.y\n    };\n  }\n  /**\n   * Scale a point by a factor\n   */\n  static scale(p, factor) {\n    return {\n      x: p.x * factor,\n      y: p.y * factor\n    };\n  }\n  /**\n   * Check if two points are equal within a tolerance\n   */\n  static equals(p1, p2, tolerance = 0.001) {\n    return Math.abs(p1.x - p2.x) < tolerance && Math.abs(p1.y - p2.y) < tolerance;\n  }\n}\n/**\n * Core path manipulation class\n */\nexport class PathManager {\n  constructor() {\n    this.paths = new Map();\n    this.idCounter = 0;\n  }\n  /**\n   * Create a new empty path\n   */\n  createPath() {\n    const path = {\n      id: this.generateId(),\n      anchorPoints: [],\n      closed: false,\n      fill: null,\n      stroke: '#000000',\n      strokeWidth: 2,\n      strokeCapStart: StrokeCapStyle.Round,\n      strokeCapEnd: StrokeCapStyle.Round,\n      selected: false\n    };\n    this.paths.set(path.id, path);\n    return path;\n  }\n  /**\n   * Get a path by ID\n   */\n  getPath(id) {\n    return this.paths.get(id);\n  }\n  /**\n   * Remove a path\n   */\n  removePath(id) {\n    return this.paths.delete(id);\n  }\n  /**\n   * Get all paths\n   */\n  getAllPaths() {\n    return Array.from(this.paths.values());\n  }\n  /**\n   * Add an anchor point to a path\n   */\n  addAnchorPoint(path, position, handleIn = null, handleOut = null) {\n    const anchorPoint = {\n      id: this.generateId(),\n      position,\n      handleIn: handleIn ? {\n        position: handleIn,\n        visible: true\n      } : null,\n      handleOut: handleOut ? {\n        position: handleOut,\n        visible: true\n      } : null,\n      mirrorMode: HandleMirrorMode.Mirrored,\n      cornerRadius: 0,\n      selected: false\n    };\n    path.anchorPoints.push(anchorPoint);\n    return anchorPoint;\n  }\n  /**\n   * Insert an anchor point at a specific index\n   */\n  insertAnchorPoint(path, index, position, handleIn = null, handleOut = null) {\n    const anchorPoint = {\n      id: this.generateId(),\n      position,\n      handleIn: handleIn ? {\n        position: handleIn,\n        visible: true\n      } : null,\n      handleOut: handleOut ? {\n        position: handleOut,\n        visible: true\n      } : null,\n      mirrorMode: HandleMirrorMode.Mirrored,\n      cornerRadius: 0,\n      selected: false\n    };\n    path.anchorPoints.splice(index, 0, anchorPoint);\n    return anchorPoint;\n  }\n  /**\n   * Remove an anchor point from a path\n   */\n  removeAnchorPoint(path, pointId) {\n    const index = path.anchorPoints.findIndex(p => p.id === pointId);\n    if (index !== -1) {\n      path.anchorPoints.splice(index, 1);\n      return true;\n    }\n    return false;\n  }\n  /**\n   * Move an anchor point\n   */\n  moveAnchorPoint(path, pointId, newPosition) {\n    const point = path.anchorPoints.find(p => p.id === pointId);\n    if (point) {\n      point.position = newPosition;\n      return true;\n    }\n    return false;\n  }\n  /**\n   * Close a path\n   */\n  closePath(path) {\n    path.closed = true;\n  }\n  /**\n   * Open a path\n   */\n  openPath(path) {\n    path.closed = false;\n  }\n  /**\n   * Get all segments of a path\n   */\n  getSegments(path) {\n    const segments = [];\n    const points = path.anchorPoints;\n    if (points.length < 2) {\n      return segments;\n    }\n    const loopEnd = path.closed ? points.length : points.length - 1;\n    for (let i = 0; i < loopEnd; i++) {\n      const startPoint = points[i];\n      const endPoint = points[(i + 1) % points.length];\n      // Determine if this is a line or curve segment\n      const hasOutHandle = startPoint.handleOut?.visible;\n      const hasInHandle = endPoint.handleIn?.visible;\n      if (hasOutHandle || hasInHandle) {\n        // Cubic Bezier curve\n        const cp1 = hasOutHandle ? PointUtils.add(startPoint.position, startPoint.handleOut.position) : startPoint.position;\n        const cp2 = hasInHandle ? PointUtils.add(endPoint.position, endPoint.handleIn.position) : endPoint.position;\n        segments.push({\n          type: SegmentType.CubicBezier,\n          startPoint,\n          endPoint,\n          controlPoint1: cp1,\n          controlPoint2: cp2\n        });\n      } else {\n        // Straight line\n        segments.push({\n          type: SegmentType.Line,\n          startPoint,\n          endPoint\n        });\n      }\n    }\n    return segments;\n  }\n  /**\n   * Generate SVG path data string from a path\n   */\n  toSVGPath(path) {\n    const segments = this.getSegments(path);\n    if (segments.length === 0) {\n      return '';\n    }\n    const parts = [];\n    const firstPoint = segments[0].startPoint.position;\n    parts.push(`M ${firstPoint.x} ${firstPoint.y}`);\n    for (const segment of segments) {\n      if (segment.type === SegmentType.Line) {\n        parts.push(`L ${segment.endPoint.position.x} ${segment.endPoint.position.y}`);\n      } else if (segment.type === SegmentType.CubicBezier) {\n        const cp1 = segment.controlPoint1;\n        const cp2 = segment.controlPoint2;\n        const end = segment.endPoint.position;\n        parts.push(`C ${cp1.x} ${cp1.y}, ${cp2.x} ${cp2.y}, ${end.x} ${end.y}`);\n      }\n    }\n    if (path.closed) {\n      parts.push('Z');\n    }\n    return parts.join(' ');\n  }\n  /**\n   * Find the closest point on a path to a given position\n   */\n  findClosestPointOnPath(path, position, threshold = 10) {\n    let closest = null;\n    for (const point of path.anchorPoints) {\n      const distance = PointUtils.distance(position, point.position);\n      if (distance <= threshold) {\n        if (!closest || distance < closest.distance) {\n          closest = {\n            anchorPoint: point,\n            distance\n          };\n        }\n      }\n    }\n    return closest;\n  }\n  /**\n   * Calculate a point on a cubic Bezier curve at parameter t (0 to 1)\n   */\n  static cubicBezierPoint(p0, cp1, cp2, p1, t) {\n    const t2 = t * t;\n    const t3 = t2 * t;\n    const mt = 1 - t;\n    const mt2 = mt * mt;\n    const mt3 = mt2 * mt;\n    return {\n      x: mt3 * p0.x + 3 * mt2 * t * cp1.x + 3 * mt * t2 * cp2.x + t3 * p1.x,\n      y: mt3 * p0.y + 3 * mt2 * t * cp1.y + 3 * mt * t2 * cp2.y + t3 * p1.y\n    };\n  }\n  generateId() {\n    return `point-${this.idCounter++}`;\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}